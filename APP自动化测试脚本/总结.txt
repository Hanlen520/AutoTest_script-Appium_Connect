1、先安装mysql数据库。
1.1、登录到MySQL

当 MySQL 服务已经运行时, 我们可以通过MySQL自带的客户端工具登录到MySQL数据库中, 首先打开命令提示符, 输入以下格式的命名:

mysql -h 主机名 -u 用户名 -p

-h : 该命令用于指定客户端所要登录的MySQL主机名, 登录当前机器该参数可以省略;
-u : 所要登录的用户名;
-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。
以登录刚刚安装在本机的MySQL数据库为例, 在命令行下输入 mysql -u root -p 按回车确认, 如果安装正确且MySQL正在运行, 会得到以下响应:

Enter password:

若密码存在, 输入密码登录, 不存在则直接按回车登录, 按照本文中的安装方法, 默认 root 账号是无密码的。登录成功后你将会看到 Welecome to the MySQL monitor... 的提示语。

然后命令提示符会一直以 mysql> 加一个闪烁的光标等待命令的输入, 输入 exit 或 quit 退出登录。

总结：
运行数据库：mysql -h 主机名 -u 用户名 -p
创建mysql数据库：create database IOT_BULL_APP;(一条语句一定要加分号；)
创建mysql数据库并以utf-8格式编码：create database IOT_BULL_APP character set UTF8;
删除mysql数据库：DROP DATABASE 公牛智联;
查看已建立mysql数据库：show databases;


2、adb 获取设备所有信息使用adb shell getprop。指定设备的信息为adb -s 85GABMN9UDD2 shell getprop（-s）
3、如果appium服务未启动或在启动中运行测试脚本会产生
INFO:selenium.webdriver.remote.remote_connection:Could not get IP address for host: localhost
避免appium服务未完全启动开始使用监听端口的方法，监听appium服务器的绑定端口，使用了一些方法后发现获取不到端口，
或者读取不了端口数据，应该还是绑定端口有误的原因。故采用监测log日志的方式，监测到localhost的日志就删掉,此种方式太麻烦，暂时不用，使用调整等待时间
4、获取当前运行文件名os.path.basename(__file__)
5、360奇酷手机设置成自动亮度，启动APP后屏幕只会慢慢亮起造成首次控件点击失败。后期手机屏幕亮度全部取消自动亮度。
6、http://blog.csdn.net/jethai/article/details/52345081
        adb发送短信
7、生成两个log文件时在a = logging.getLogger("2")内要写“2”，不然a就是rootlogger，加了2就是logger可以多个了，不然所有logger内容都是一样的，跟随rootlogger。
8、判断文件夹是否存在使用os.path.exists('d:/assist')返回值TRUE或者FALSE
9、多进程要共享内存有3中方法，queue，Manager，（Value，array）
    但在使用过程中可以使用直接传入静态变量，但只能是静态不变化的，含有内存地址类是不能当做参数传入多进程的。（目前是log文件的内存地址，更详细有待后续再试）
    纯字符字典，列表等是可以当作参数传入使用的。
10、在写调用库的时候最好不要使用全局变量。用函数然后return的方式在其他调用会更节省资源，在form import调用时就不会运行两次。
11、程序运行返回值要做判断，控制命令行的执行结果
12、文件夹的命名方式要考虑同一类型的两部手机会不会重复，可以使用手机名称+udid的方式。
13、appium并发测试的启动方式：加上——bp参数（与安卓通讯的端口），对appium的功能还不是很熟悉。边用边学
14、Android的toast消息机制uiautomatorviewer获取不到，appium无法识别，暂时使用截屏方式解决
15、WPS的excel中sheet名称不能包含[]，能包含(){}，但是在adb中名称不能包含()，所以最终的命名取为{}
16、os.getenv('Temp')可以获得path中变量的值，此值为C:\Users\Maiyajj\AppData\Local\Temp
17、time.strftime("%Y-%m-%d %H:%M:%S") → '2017-05-03 15:18:28'
    a = time.strptime('2017-05-03 15:18:28', "%Y-%m-%d %H:%M:%S") ↓
                time.struct_time(tm_year=2017, tm_mon=5, tm_mday=3, tm_hour=15, tm_min=18, tm_sec=28, tm_wday=2, tm_yday=123, tm_isdst=-1)
    a[0],a[1]...
18、list中的set是无序的，不能保证顺序a = [5,4,3,2,1]经过set后set(a)输出的值为set类型值“set([1,2,3,4,5])”，是没有取值属性的：例如set([**])[0]是非法的。
19、xlwt三方库中的单元格格式有两种方法：1、easyxf；2、XFStyle()
    1、easyxf()参数：参考文件C:/Python/Python27/Lib/site-packages/xlwt/Formatting.py
        self.num_format_str  = 'General'
        self.font            = Formatting.Font()
        self.alignment       = Formatting.Alignment()
        self.borders         = Formatting.Borders()
        self.pattern         = Formatting.Pattern()
        self.protection      = Formatting.Protection()
        编写格式：easyxf('font: height 240, name Arial, colour_index black, bold on, italic on;'
                        'align: wrap on, vert centre, horiz left;'
                        'borders: top NO_LINE, bottom THIN, left dashed, right double;'
                        'pattern: pattern solid, fore_colour 23')
    2、XFStyle()参数
        self.xfstyle = XFStyle()

        font = Font()
        font.height = 11 * 20
        font.name = u"宋体"

        borders = Borders()
        borders.top = Borders.THIN
        borders.bottom = Borders.THIN
        borders.left = Borders.THIN
        borders.right = Borders.THIN

        align = Alignment()
        align.horz = Alignment.HORZ_CENTER

        self.xfstyle.font = font
        self.xfstyle.borders = borders
        self.xfstyle.alignment = align

        使用格式为self.xfstyle：
        self.sheet.write(total_row, 7, Formula(formula), self.xfstyle)
    font参数有(
        self.height = 0x00C8 # 200: this is font with height 10 points,  # 高度
        self.italic = False  # 倾斜
        self.struck_out = False  # 删除线
        self.outline = False  # 轮廓
        self.shadow = False  # 阴影
        self.colour_index = 0x7FFF  # 文字颜色
        self.bold = False  # 粗体
        self._weight = 0x0190 # 0x02BC gives bold font  # 宽度
        self.escapement = self.ESCAPEMENT_NONE  # 上标下标
        self.underline = self.UNDERLINE_NONE  # 下划线
        self.family = self.FAMILY_NONE  # 不知道啥，用不到吧
        self.charset = self.CHARSET_SYS_DEFAULT  # 字符集
        self.name = 'Arial'  # 字体)
    alignment参数有(
        self.horz = self.HORZ_GENERAL  # 左右对齐
        self.vert = self.VERT_BOTTOM  # 上下对齐
        self.dire = self.DIRECTION_GENERAL  #
        self.orie = self.ORIENTATION_NOT_ROTATED
        self.rota = self.ROTATION_0_ANGLE
        self.wrap = self.NOT_WRAP_AT_RIGHT  # 自动换行
        self.shri = self.NOT_SHRINK_TO_FIT  # 自动收缩
        self.inde = 0
        self.merg = 0)
    borders参数有(
        self.left   = self.NO_LINE  # 边框线条
        self.right  = self.NO_LINE
        self.top    = self.NO_LINE
        self.bottom = self.NO_LINE
        self.diag   = self.NO_LINE

        self.left_colour   = 0x40  # 边框颜色
        self.right_colour  = 0x40
        self.top_colour    = 0x40
        self.bottom_colour = 0x40
        self.diag_colour   = 0x40

        self.need_diag1 = self.NO_NEED_DIAG1
        self.need_diag2 = self.NO_NEED_DIAG2)
    pattern参数有(
        self.pattern = self.NO_PATTERN  # SOLID_PATTERN  # 是否颜色填充
        self.pattern_fore_colour = 0x40
        self.pattern_back_colour = 0x41)
    Protection参数有(
        self.cell_locked = 1
        self.formula_hidden = 0)

20、xlwt支持改写，加内部参数即可cell_overwrite_ok=True
# self.sheet = self.book.add_sheet(self.sheet_name, cell_overwrite_ok=True)
21、涉及到多目录调用时，编写脚本文件时会显示调用错误，虽然运行没有问题，但是非常难看。为解决此问题需要将工程目录文件写入PYTHONPATH目录中，
    详细设置的网址如下；http://blog.csdn.net/wh357589873/article/details/53204024
22、xlwt在单元格的格式循环调用的情况下会抛出Python xlwt : More than 4094 XFs (styles) 的错误，解决办法就是将格式保存为变量来调用
    网址：http://www.cnblogs.com/jaw-crusher/p/3741224.html
23、直接记录错误信息的三方库为traceback，import traceback;输出错误信息语句为traceback.format_exc()
24、多文件调用抛出的异常也是可以捕捉在函数调用的地方捕捉到的，跟踪异常信息获取异常控制台信息http://www.quke.org/post/python-exception-info.html
25、获取异常的名称e.__class__.__name__
26、Excel单元格格式化文本的操作为sheet.write(0, 2, "0", xlwt.easyxf("****", num_format_str="dd / mm / yyyy"))
27、A文件中的变量driver在B文件内初始化，然后这个driver变量竟然在A文件中无法使用
28、adb崩掉了
29、脚本在分配用户名的时候是动态分配的，但是多台电脑运行脚本的情况下就不知道用户名是否冲突了
30、error: Error killing ADB server, going to see if it's online anyway在手机USB突然掉线的情况下再次恢复会报这个错
    下一步就是判断这个错是哪里报出的，怎么处理
    info: [debug] executing cmd: C:\Python\android-sdk-windows\platform-tools\adb.exe devices
    info: [debug] Could not find devices, restarting adb server...
    info: [debug] executing cmd: C:\Python\android-sdk-windows\platform-tools\adb.exe kill-server
    error: Error killing ADB server, going to see if it's online anyway
    info: [debug] Getting connected devices...
    info: [debug] executing cmd: C:\Python\android-sdk-windows\platform-tools\adb.exe devices
    info: [debug] Sent shutdown command, waiting for UiAutomator to stop...
    warn: UiAutomator did not shut down fast enough, calling it gone
    info: [debug] Cleaning up android objects
    info: [debug] Cleaning up appium session
    error: Failed to start an Appium session, err was: Error: Could not find a connected Android device.
    info: [debug] Error: Could not find a connected Android device.
        at [object Object].ADB.getDevicesWithRetry (C:\Python\Appium\node_modules\appium\node_modules\appium-adb\lib\adb.js:606:15)
        at [object Object].androidCommon.prepareActiveDevice (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:400:12)
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:326:26)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:157:25
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:248:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:612:34
        at [object Object].androidCommon.ensureDeviceLocale (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:371:45)
        at [object Object].androidCommon.prepareEmulator (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:364:10)
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:325:26)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:157:25
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:248:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:612:34
        at [object Object].androidCommon.checkAppPresent (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:336:5)
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:324:26)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at async.eachSeries (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:162:9)
        at _asyncMap (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:245:13)
        at Object.mapSeries (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:228:23)
        at Object.async.series (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:605:19)
        at [object Object].androidCommon.prepareDevice (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:323:9)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:157:25
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:248:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:612:34
        at [object Object].Android.initUiautomator (C:\Python\Appium\node_modules\appium\lib\devices\android\android.js:140:10)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:157:25
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:248:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:612:34
        at [object Object].androidCommon.packageAndLaunchActivityFromManifest (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:670:12)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:157:25
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:248:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:612:34
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:1086:7)
        at C:\Python\Appium\node_modules\appium\node_modules\appium-adb\lib\adb.js:74:5
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\node_modules\appium-adb\lib\adb.js:137:5)
        at [object Object].ADB.checkSdkBinaryPresent (C:\Python\Appium\node_modules\appium\node_modules\appium-adb\lib\adb.js:116:5)
        at [object Object].ADB.checkAdbPresent (C:\Python\Appium\node_modules\appium\node_modules\appium-adb\lib\adb.js:134:8)
        at Function.ADB.createADB (C:\Python\Appium\node_modules\appium\node_modules\appium-adb\lib\adb.js:73:7)
        at [object Object].androidCommon.initAdb (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:1083:9)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:607:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:246:17
        at iterate (C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:146:13)
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:157:25
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:248:21
        at C:\Python\Appium\node_modules\appium\node_modules\async\lib\async.js:612:34
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:1077:12)
        at [object Object].<anonymous> (C:\Python\Appium\node_modules\appium\lib\devices\android\android-common.js:1064:12)
        at ChildProcess.exithandler (child_process.js:204:7)
    info: [debug] Responding to client with error: {"status":33,"value":{"message":"A new session could not be created. (Original error: Could not find a connected Android device.)","origValue":"Could not find a connected Android device."},"sessionId":null}
    info: <-- POST /wd/hub/session 500 31543.091 ms - 206

    上述即为抓到的appium服务器端的报错信息，如下为client端的错误信息
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "C:\Python\Python27\lib\site-packages\appium\webdriver\webdriver.py", line 36, in __init__
        super(WebDriver, self).__init__(command_executor, desired_capabilities, browser_profile, proxy, keep_alive)
      File "C:\Python\Python27\lib\site-packages\selenium\webdriver\remote\webdriver.py", line 98, in __init__
        self.start_session(desired_capabilities, browser_profile)
      File "C:\Python\Python27\lib\site-packages\selenium\webdriver\remote\webdriver.py", line 188, in start_session
        response = self.execute(Command.NEW_SESSION, parameters)
      File "C:\Python\Python27\lib\site-packages\selenium\webdriver\remote\webdriver.py", line 252, in execute
        self.error_handler.check_response(response)
      File "C:\Python\Python27\lib\site-packages\selenium\webdriver\remote\errorhandler.py", line 194, in check_response
        raise exception_class(message, screen, stacktrace)
    selenium.common.exceptions.WebDriverException: Message: A new session could not be created. (Original error: Could not find a connected Android device.)
    报的错为WebDriverException，内容为Message: A new session could not be created. (Original error: Could not find a connected Android device.)
    所以监测WebDriverException这个错误即可，保留5037端口不被占用即可解决此问题。同时在脚本运行时手机不要安装任何手机助手类软件，特别是PP助手，
    杀掉进程后又会出现，循环启动他的服务，直接卸载。
31、以前一直 存在的appium服务就一直死了的原因是appium服务再启动过程中，检查appium服务是否启动函数的时延太少，只有10S，超时reset_port函数直接又把appium服务杀死了，造成appium启动函数的端口检测陷入了死循环。
先加入appium服务启动函数30S超时，检查appium服务函数超时时间改为60S。